/*

指针

	1、指针的基本概念
	
		・可以通过指针间接访问内存；
		
		・内存编号是从 0 开始记录的，一般用十六进制数字表示；

		・可以利用指针变量保存地址；

		・指针的本质就是一个地址，可以通过指针来保存一个地址；

		・可以利用指针来记录一个数据所在的内存编号（例如：0x0000），可以说指针的目的就是用来记录内存编号的；



	2、指针变量的定义和使用

		指针变量定义的语法：
		
			数据类型*  指针变量名；例如：int* p;


		使用指针（解引用）：
			
			通过解引用的方式（*p）可以找到指针指向的内存，即找到指针指向的内存中的数据；即解引用可以访问内存中的数据；



	3、指针所占内存空间

		一般格式：int* p = &a;

		提问：指针也是一种数据类型，那么指针这种数据类型占用多少内存空间呢?

		回答：不管是什么数据类型(int、double、char)，在32位操作系统(x86)下，占用4个字节空间；64位操作系统(x64)下，占用8个字节空间。

	

	4、1 空指针

		概念：指针变量指向内存中编号为 0 的空间；

		用途：初始化指针变量；

		注意：空指针指向的内存（例如int* p = NULL）是不可以访问的（对其解引用 *p = 100，运行时会报错）；因为0~255之间的内存编号是系统占用的，因此不可以访问；

		使用：当定义指针时，例如：int * p；当不知道指针的指向，指向哪里合适时，这时可以使用：int * p = NULL;



	4、2 野指针

		概念：指针变量指向非法的内存空间；

		总结：空指针和野指针都不是我们申请的空间，因此不要访问，访问就要报错；



	5、const修饰指针
	
		const修饰指针有三种情况：

			1.const修饰指针（常量指针）

				例如：const int* p = &a;

				特点：指针的指向可以修改，但是指针指向的值不可以改 ―― 例如：int a = 10; int b = 10; int * p = &a; ―― *p = 20;(错)  p = &b;(对)


			2.const修饰常量（指针常量）

				例如：int* const p = &a;

				特点：指针的指向不可以改，但是指针指向的值可以修改 ―― 例如：int a = 10; int b = 10; int * p = &a; ―― *p = 20;(对)  p = &b;(错)


			3.const既修饰指针，又修饰常量

				例如：const int* const p = &a;

				特点：指针的指向和指针指向的值都不可以修改 ―― 例如：int a = 10; int b = 10; int * p = &a; -- *p = 20;(错)  p = &b;(错)



	6、指针和数组
		
		作用：利用指针访问数组中的元素；



	7、指针和函数

		作用：利用指针作为函数的形参时，可以修改实参的值（地址传递）；


			void swap01(int num1, int num2)
			{
				int temp = num1;
				num1 = num2;
				num2 = temp;
			}
			void swap02(int* p1, int* p2)
			{
				int temp = *p1;
				*p1 = *p2;
				*p2 = temp;
			}
			
			int main()
			{
				int a = 10;
				int b = 20;

				值传递（主函数中 a、b 的值不会发生改变）
				swap01(a, b);


				地址传递（主函数中 a、b 的值会发生改变）
				swap02(&a, &b);
			}



		值传递

			・首先，从main()函数开始执行：

					执行 int a = 10; int b = 20; 系统会自动的给实参变量 a、b 分配两个内存地址用于存放变量 a、b 的数据；
		

			・其次，执行到swap01(a, b);
				
					执行 int num1 = a; int num2 = b; 系统会给形参变量 num1、num2 分配内存空间用于存放变量 a、b 传递过来的数据（类似复制粘贴）

					执行 int temp = num1; 系统会给临时变量 temp 分配一个内存空间用于存放形参变量 num1 接收到的数据，即 a 的值10；

					后同理；


			・所以，在 void swap01() 函数中：

					实际上交换值的顺序是：temp = num1, num1 = num2, num2 = temp;

					num1、num2 的值是 a、b 传递过来的，在交换值的过程中，a、b 两个实参值只是起到了一个传递值的作用，a、b 实际上并未进入到 swap01() 函数中

					交换值的过程只发生在 num1、num2、temp 三个值之间，所以值传递不会改变实参的实际值。



		地址传递：

			・首先，从main()函数开始执行：
			
					执行 int a = 10; int b = 20; 系统会自动的给实参变量 a、b 分配两个内存地址用于存放变量 a、b 的数据；


			・其次，执行到swap02(&a, &b);

					执行 int* p1 = &a; int* p2 = &b; 系统会自动的给指针形参变量 p1、p2 分配内存空间用于存放变量 a、b 的内存地址；

					执行 int temp = *p1; 系统会自动的给临时变量 temp 分配内存空间，用于存放指针形参变量 p1 指向的内存地址解引用后数据，即 a 的值10；

					后同理；


			・解引用操作；例如：*p1，就是找到指针形参变量 p1 存放的内存地址所指向的数据；即 *p1 = a ，因为他俩是一个地址，是一个房间，是一个东西；


			・所以，在 main() 函数中调用 void swap02() 函数时，传递的给指针形参变量 p1、p2 的是实参变量 a、b 的地址 &a、&b；
					
					a = 10;
					b = 20;

					int* p1 = &a;（把 int* 看成指针特有的数据类型即可，定义指针变量语法：数据类型 变量名）
					int* p2 = &b;

					p1 = &a;
					p2 = &b;

					*p1 = a;
					*p2 = b;


			・最终，在交换值的过程中带动了实参 a、b，是五个数值之间的变换，所以地址传递会改变实参的实际值。

*/